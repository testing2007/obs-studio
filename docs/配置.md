1. 配置基本方法
```c
#include "libobs/util/config-file.h"

config_t *cfg = config_create("to config file path");

const char *format = config_get_string(cfg, "AdvOut", "FFFormat"); //获取容器格式

config_set_string(cfg, "AdvOut", "FFFormat", "newFormatValue"); //设置容器格式, 空值为 nullptr;

config_save_safe(cfg, "tmp", nullptr); //保存
```

2. 获取所有容器格式
```c
	formats.reset(ff_format_supported());
	const ff_format_desc *format = formats.get();

	while (format != nullptr) {
		bool audio = ff_format_desc_has_audio(format);
		bool video = ff_format_desc_has_video(format);
		FormatDesc formatDesc(ff_format_desc_name(format),
				      ff_format_desc_mime_type(format), format);
		if (audio || video) {
			QString itemText(ff_format_desc_name(format));
			if (audio ^ video)
				itemText += QString(" (%1)").arg(
					audio ? AUDIO_STR : VIDEO_STR);

			ui->advOutFFFormat->addItem(
				itemText, QVariant::fromValue(formatDesc));
		}

		format = ff_format_desc_next(format);
	}
```
3. 选择容器格式
```c++
void OBSBasicSettings::on_advOutFFFormat_currentIndexChanged(int idx)
{
	const QVariant itemDataVariant = ui->advOutFFFormat->itemData(idx);

	if (!itemDataVariant.isNull()) {
		FormatDesc desc = itemDataVariant.value<FormatDesc>();
		SetAdvOutputFFmpegEnablement(
			FF_CODEC_AUDIO, ff_format_desc_has_audio(desc.desc),
			false);
		SetAdvOutputFFmpegEnablement(
			FF_CODEC_VIDEO, ff_format_desc_has_video(desc.desc),
			false);
		ReloadCodecs(desc.desc);
		ui->advOutFFFormatDesc->setText(
			ff_format_desc_long_name(desc.desc));

		CodecDesc defaultAudioCodecDesc =
			GetDefaultCodecDesc(desc.desc, FF_CODEC_AUDIO);
		CodecDesc defaultVideoCodecDesc =
			GetDefaultCodecDesc(desc.desc, FF_CODEC_VIDEO);
		SelectEncoder(ui->advOutFFAEncoder, defaultAudioCodecDesc.name,
			      defaultAudioCodecDesc.id);
		SelectEncoder(ui->advOutFFVEncoder, defaultVideoCodecDesc.name,
			      defaultVideoCodecDesc.id);
	} else {
		ReloadCodecs(nullptr);
		ui->advOutFFFormatDesc->setText(DEFAULT_CONTAINER_STR);
	}
}

void OBSBasicSettings::SetAdvOutputFFmpegEnablement(ff_codec_type encoderType,
						    bool enabled,
						    bool enableEncoder)
{
	bool rescale = config_get_bool(main->Config(), "AdvOut", "FFRescale");

	switch (encoderType) {
	case FF_CODEC_VIDEO:
		ui->advOutFFVBitrate->setEnabled(enabled);
		ui->advOutFFVGOPSize->setEnabled(enabled);
		ui->advOutFFUseRescale->setEnabled(enabled);
		ui->advOutFFRescale->setEnabled(enabled && rescale);
		ui->advOutFFVEncoder->setEnabled(enabled || enableEncoder);
		ui->advOutFFVCfg->setEnabled(enabled);
		break;
	case FF_CODEC_AUDIO:
		ui->advOutFFABitrate->setEnabled(enabled);
		ui->advOutFFAEncoder->setEnabled(enabled || enableEncoder);
		ui->advOutFFACfg->setEnabled(enabled);
		ui->advOutFFTrack1->setEnabled(enabled);
		ui->advOutFFTrack2->setEnabled(enabled);
		ui->advOutFFTrack3->setEnabled(enabled);
		ui->advOutFFTrack4->setEnabled(enabled);
		ui->advOutFFTrack5->setEnabled(enabled);
		ui->advOutFFTrack6->setEnabled(enabled);
	default:
		break;
	}
}

void OBSBasicSettings::ReloadCodecs(const ff_format_desc *formatDesc)
{
	ui->advOutFFAEncoder->blockSignals(true);
	ui->advOutFFVEncoder->blockSignals(true);
	ui->advOutFFAEncoder->clear();
	ui->advOutFFVEncoder->clear();

	if (formatDesc == nullptr)
		return;

	bool ignore_compatability = ui->advOutFFIgnoreCompat->isChecked();
	OBSFFCodecDesc codecDescs(
		ff_codec_supported(formatDesc, ignore_compatability));

	const ff_codec_desc *codec = codecDescs.get();

	while (codec != nullptr) {
		switch (ff_codec_desc_type(codec)) {
		case FF_CODEC_AUDIO:
			AddCodec(ui->advOutFFAEncoder, codec);
			break;
		case FF_CODEC_VIDEO:
			AddCodec(ui->advOutFFVEncoder, codec);
			break;
		default:
			break;
		}

		codec = ff_codec_desc_next(codec);
	}

	if (ff_format_desc_has_audio(formatDesc))
		AddDefaultCodec(ui->advOutFFAEncoder, formatDesc,
				FF_CODEC_AUDIO);
	if (ff_format_desc_has_video(formatDesc))
		AddDefaultCodec(ui->advOutFFVEncoder, formatDesc,
				FF_CODEC_VIDEO);

	ui->advOutFFAEncoder->model()->sort(0);
	ui->advOutFFVEncoder->model()->sort(0);

	QVariant disable = QVariant::fromValue(CodecDesc());

	ui->advOutFFAEncoder->insertItem(0, AV_ENCODER_DISABLE_STR, disable);
	ui->advOutFFVEncoder->insertItem(0, AV_ENCODER_DISABLE_STR, disable);

	ui->advOutFFAEncoder->blockSignals(false);
	ui->advOutFFVEncoder->blockSignals(false);
}
```

4. 保存修改设置会触发链路重新创建
```c++
void OBSBasicSettings::SaveSettings()
{
	if (generalChanged) //##通用
		SaveGeneralSettings();
	if (stream1Changed)//##推流
		SaveStream1Settings();
	if (outputsChanged)//##输出
		SaveOutputSettings();
	if (audioChanged)//##音频
		SaveAudioSettings();
	if (videoChanged)//##视频
		SaveVideoSettings();
	if (hotkeysChanged)//##热键
		SaveHotkeySettings();
	if (advancedChanged)//##高级
		SaveAdvancedSettings();

	if (videoChanged || advancedChanged)
		main->ResetVideo();

	config_save_safe(main->Config(), "tmp", nullptr);
	config_save_safe(GetGlobalConfig(), "tmp", nullptr);
	main->SaveProject();

	if (Changed()) {
		std::string changed;
		if (generalChanged)
			AddChangedVal(changed, "general");
		if (stream1Changed)
			AddChangedVal(changed, "stream 1");
		if (outputsChanged)
			AddChangedVal(changed, "outputs");
		if (audioChanged)
			AddChangedVal(changed, "audio");
		if (videoChanged)
			AddChangedVal(changed, "video");
		if (hotkeysChanged)
			AddChangedVal(changed, "hotkeys");
		if (advancedChanged)
			AddChangedVal(changed, "advanced");

		blog(LOG_INFO, "Settings changed (%s)", changed.c_str());
		blog(LOG_INFO, MINOR_SEPARATOR);
	}

	bool langChanged = (ui->language->currentIndex() != prevLangIndex);
	bool audioRestart = (ui->channelSetup->currentIndex() != channelIndex ||
			     ui->sampleRate->currentIndex() != sampleRateIndex);
	bool browserHWAccelChanged =
		(ui->browserHWAccel &&
		 ui->browserHWAccel->isChecked() != prevBrowserAccel);

	if (langChanged || audioRestart || browserHWAccelChanged)
		restart = true;
	else
		restart = false;
}
```
服务参数：rtmp_custom


输出参数：

需要设置参数：
推流路径：rtmp://**
容器格式：
容器格式说明：
混流器设置(可选)：
视频比特率：
关键帧间隔(帧)：
    重新缩放输出：
        显示所有编码器(即使可能不兼容)

视频编码器:无 或 有
视频编码器设置：tune=zerolatency

音频编码器：
音频编码器设置(可选)：
音频比特率：
音轨：


1. 界面 与 SDK 指责分配；
   

2. 获取 所有音视频编解码 信息接口；（结构体：containerName, aid, aname, vid, vname）
   利用 fflib 获取所有支持的音视频格式，ff_format_desc* 来表示

3. 与 服务配置 如何关联
   推流服务：  通过 stream1Changed 来判断， 单独有一个 设置项 window-basic-setting-stream.cpp

4. 切换 容器 / 音视频编码器 操作；
   根据容器格式， 决定音视频编码格式

5. 应用 / 取消 / 确认 做了什么；
   获取控件上相应值，然后保存

   确定：

6. 显示尺寸修改参数 与 显示 如何关联保存
   基础（画布）分辨率
   输出（缩放）分辨率
   缩小方法：
   常用FPS值（帧率）

7. output 的三种情况
FFVEncoder

bool ffmpegOutput;

### 默认的
```c++
windows-basic-main-outputs.cpp
AdvancedOutput::AdvancedOutput(OBSBasic *main_) : BasicOutputHandler(main_) {

    if (ffmpegOutput) {
   		fileOutput = obs_output_create(
   			"ffmpeg_output", "adv_ffmpeg_output", nullptr, nullptr);
    } else {
   		fileOutput = obs_output_create(
   			"ffmpeg_muxer", "adv_file_output", nullptr, nullptr);
    }

    const char *streamEncoder = config_get_string(main->Config(), "AdvOut", "Encoder");
	h264Streaming = obs_video_encoder_create(
		streamEncoder, "streaming_h264", streamEncSettings, nullptr);
}

inline void AdvancedOutput::SetupFFmpeg() {
   const char *vEncoder =
   config_get_string(main->Config(), "AdvOut", "FFVEncoder");

   obs_data_t *settings = obs_data_create();
   obs_data_set_string(settings, "video_encoder", vEncoder);

   obs_output_set_media(fileOutput, obs_get_video(), obs_get_audio());
   obs_output_update(fileOutput, settings);

}
```




变量：
	bool generalChanged = false;
	bool stream1Changed = false;
	bool outputsChanged = false;
	bool audioChanged = false;
	bool videoChanged = false;
	bool hotkeysChanged = false;
	bool advancedChanged = false;

函数：
	void LoadEncoderTypes(); //
	void LoadColorRanges();
	List<FormatDesc*> LoadFormats();//## 获取所有 Formats, FormatDesc 重新定义，必须包含 ff_format_desc*
	void ReloadCodecs(const ff_format_desc *formatDesc);//## 通过选中某个容器， 然后重新对音视频进行装填

	void LoadGeneralSettings();
	void LoadStream1Settings();
	void LoadOutputSettings();
	void LoadAudioSettings();
	void LoadVideoSettings();
	void LoadHotkeySettings(obs_hotkey_id ignoreKey = OBS_INVALID_HOTKEY_ID);
	void LoadAdvancedSettings();
	void LoadSettings(bool changedOnly);

private slots:
	void UpdateServerList();

private:
	/* output */
	void LoadSimpleOutputSettings();
	void LoadAdvOutputStreamingSettings();
	void LoadAdvOutputStreamingEncoderProperties();
	void LoadAdvOutputRecordingSettings();
	void LoadAdvOutputRecordingEncoderProperties();
	void LoadAdvOutputFFmpegSettings();
	void LoadAdvOutputAudioSettings();
	void SetAdvOutputFFmpegEnablement(ff_codec_type encoderType,
					  bool enabled,
					  bool enableEncode = false);

### 如何做
#### 依赖
ff_util.h

struct ff_format_desc {
	const char *name;
	const char *long_name;
	const char *mime_type;
	const char *extensions;
	enum AVCodecID audio_codec;
	enum AVCodecID video_codec;
	const struct AVCodecTag *const *codec_tags;
	const struct ff_format_desc *next;
};

struct ff_codec_desc {
	const char *name;
	const char *long_name;
	int id;
	bool alias;
	const char *base_name;
	enum ff_codec_type type;
	const struct ff_codec_desc *next;
};

### 初始化
	// Initialize libff library
	ff_init();

	installEventFilter(new SettingsEventFilter());

	LoadEncoderTypes();
	LoadColorRanges();
	LoadFormats();

    InitStreamPage();
	LoadSettings(false);


### obs.c 所有枚举类型实现，变量均定义在 obs-internal.h
bool obs_enum_source_types(size_t idx, const char **id)
{
	if (idx >= obs->source_types.num)
		return false;
	*id = obs->source_types.array[idx].id;
	return true;
}

bool obs_enum_input_types(size_t idx, const char **id)
{
	if (idx >= obs->input_types.num)
		return false;
	*id = obs->input_types.array[idx].id;
	return true;
}

bool obs_enum_input_types2(size_t idx, const char **id,
			   const char **unversioned_id)
{
	if (idx >= obs->input_types.num)
		return false;
	if (id)
		*id = obs->input_types.array[idx].id;
	if (unversioned_id)
		*unversioned_id = obs->input_types.array[idx].unversioned_id;
	return true;
}

bool obs_enum_filter_types(size_t idx, const char **id)
{
	if (idx >= obs->filter_types.num)
		return false;
	*id = obs->filter_types.array[idx].id;
	return true;
}

bool obs_enum_transition_types(size_t idx, const char **id)
{
	if (idx >= obs->transition_types.num)
		return false;
	*id = obs->transition_types.array[idx].id;
	return true;
}

bool obs_enum_output_types(size_t idx, const char **id)
{
	if (idx >= obs->output_types.num)
		return false;
	*id = obs->output_types.array[idx].id;
	return true;
}

bool obs_enum_encoder_types(size_t idx, const char **id)
{
	if (idx >= obs->encoder_types.num)
		return false;
	*id = obs->encoder_types.array[idx].id;
	return true;
}

bool obs_enum_service_types(size_t idx, const char **id)
{
	if (idx >= obs->service_types.num)
		return false;
	*id = obs->service_types.array[idx].id;
	return true;
}


### 需要提供的接口
